{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.notifyOfNext = notifyOfNext;\nexports.cancelNotifyOfNext = cancelNotifyOfNext;\nexports.notifyOfAll = notifyOfAll;\n\nvar _constants = require('./constants'); // list of callbacks that are called every time the event fires\n// only one callback function per eventType b/c notifyOfAll is only used by inputTracker\n// {\n//   eventType: callback,\n//   eventA: cbFunctionA,\n//   eventB: cbFunctionB,\n// }\n\n\nvar notifyOfAllSubs = {}; // list of callbacks that are called only for the next event and then deleted\n// {\n//   eventType: [{ id, callback }, { id, callback }, ...],\n//   eventA: [{ id: 1, callback: cbFunctionA }, { id: 2, callback: cbFunctionB }],\n//   eventB: [{ id: 3, callback: cbFunctionC }, { id: 4, callback: cbFunctionD }],\n// }\n\nvar notifyOfNextSubs = {}; // list of sub IDs with corresponding index in notifyOfNextSubs array for easy cancelation of sub\n// {\n//   eventType: { id: indexInNotifyOfNextSubsArray },\n//   eventA: { 1: 0, 2: 1 },\n//   eventB: { 3: 0, 4: 1 },\n// }\n\nvar subsIDs = {}; // generate unique ID\n\nvar idPlace = 0;\n\nfunction nextID(eType) {\n  if (idPlace === Number.MAX_SAFE_INTEGER) idPlace = 0;\n  idPlace++;\n  if (subsIDs[eType][idPlace] === undefined) return idPlace;\n  return nextID(eType);\n} // subscribe to notifyOfNext, returns the ID of the subscription so it can be canceled\n\n\nfunction notifyOfNext(eType, callback) {\n  var id = nextID(eType);\n  subsIDs[eType][id] = notifyOfNextSubs[eType].push({\n    id: id,\n    callback: callback\n  }) - 1;\n  return id;\n} // cancel an already existing subscription\n\n\nvar blankFunction = function blankFunction() {};\n\nfunction cancelNotifyOfNext(eType, id) {\n  if (subsIDs[eType][id] !== 'undefined') {\n    notifyOfNextSubs[eType][subsIDs[eType][id]].callback = blankFunction;\n    delete subsIDs[eType][id];\n  }\n} // subscribe to notifyOfAll, only used by inputTracker\n\n\nfunction notifyOfAll(eTypes, callback) {\n  eTypes.forEach(function (eType) {\n    notifyOfAllSubs[eType] = callback;\n  });\n} // notify all when event comes in\n\n\nfunction handleNotifyAll(e) {\n  notifyOfAllSubs[e.type](e);\n} // notify next when event comes, if the callback returns 'reNotifyOfNext', then re-subscribe\n// using the same id\n\n\nfunction handleNotifyNext(e) {\n  if (notifyOfNextSubs[e.type].length === 0) return;\n  e.persist = blankFunction;\n  var reNotifyOfNext = [];\n  var reNotifyOfNextIDs = {};\n  notifyOfNextSubs[e.type].forEach(function (sub) {\n    if (sub.callback(e) === 'reNotifyOfNext') {\n      reNotifyOfNextIDs[sub.id] = reNotifyOfNext.push(sub) - 1;\n    }\n  });\n  notifyOfNextSubs[e.type] = reNotifyOfNext;\n  subsIDs[e.type] = reNotifyOfNextIDs;\n}\n\nfunction handleNotifyAllAndNext(e) {\n  handleNotifyAll(e);\n  handleNotifyNext(e);\n} // setup event listeners and notification system for events\n\n\nfunction setupEvent(element, eType, handler, capture) {\n  notifyOfNextSubs[eType] = [];\n  subsIDs[eType] = {};\n  element.addEventListener(eType, handler, _constants.passiveEventSupport ? {\n    capture: capture,\n    // don't set click listener as passive because syntheticClick may call preventDefault\n    passive: eType !== 'click'\n  } : capture);\n}\n\nif (_constants.deviceHasTouch) {\n  // set up click listener for use with syntheticClick on touch devices\n  setupEvent(window, 'click', handleNotifyAll, true); // if the device has touch, then setup event listeners for touch events\n\n  Object.keys(_constants.touchEvents).forEach(function (eType) {\n    setupEvent(document, eType, eType === 'touchstart' ? handleNotifyAllAndNext : handleNotifyAll, true);\n  });\n} // if the device has a mouse, then setup event listeners for mouse events,\n// see manageNotifyOfNext and handleNotifyOfNext in index.js for more info\n// on why a specific listener is set\n\n\nif (_constants.deviceHasMouse) {\n  Object.keys(_constants.mouseEvents).forEach(function (eType) {\n    setupEvent(document, eType, eType === 'mouseenter' ? handleNotifyAllAndNext : handleNotifyAll, // don't use capture for enter/leave so the event only fires when the mouse leaves the doc\n    !(eType === 'mouseenter' || eType === 'mouseleave'));\n  });\n  setupEvent(document, 'dragstart', handleNotifyNext, true);\n\n  if (_constants.passiveEventSupport) {\n    setupEvent(document, 'scroll', handleNotifyNext, true);\n  }\n\n  notifyOfNextSubs.mutation = [];\n  subsIDs.mutation = {};\n  var mutationEvent = (0, _constants.dummyEvent)('mutation');\n  var mo = window.MutationObserver ? new MutationObserver(handleNotifyNext.bind(null, mutationEvent)) : {\n    observe: function observe() {}\n  };\n  mo.observe(document, {\n    childList: true,\n    attributes: true,\n    subtree: true,\n    characterData: true\n  });\n} // always set focus/blur listener on the window so know when leave/enter the app/window/tab\n\n\n['focus', 'blur'].forEach(function (eType) {\n  setupEvent(window, eType, handleNotifyNext, false);\n}); // always set keydown listener for enter key events for form submission\n\nsetupEvent(document, 'keydown', handleNotifyAll, true);","map":null,"metadata":{},"sourceType":"script"}